import { RTCDataChannel } from "./dataChannel";
import { EventTarget } from "./helper";
import { type Address, Event, type InterfaceAddresses } from "./imports/common";
import type { CandidatePair, Message, Protocol } from "./imports/ice";
import { type Direction, MediaStream, type MediaStreamTrack, type RTCRtpCodecParameters, type RTCRtpHeaderExtensionParameters, RTCRtpReceiver, RTCRtpSender, RTCRtpTransceiver, type TransceiverOptions } from "./media";
import { GroupDescription, MediaDescription, SessionDescription } from "./sdp";
import { type DtlsKeys, RTCDtlsTransport } from "./transport/dtls";
import { type IceGathererState, type RTCIceCandidate, type RTCIceCandidateInit, type RTCIceConnectionState, RTCIceTransport } from "./transport/ice";
import { RTCSctpTransport } from "./transport/sctp";
import type { ConnectionState, Kind, RTCSignalingState } from "./types/domain";
import type { Callback, CallbackWithValue } from "./types/util";
export declare class RTCPeerConnection extends EventTarget {
    readonly cname: string;
    sctpTransport?: RTCSctpTransport;
    config: Required<PeerConfig>;
    connectionState: ConnectionState;
    iceConnectionState: RTCIceConnectionState;
    iceGatheringState: IceGathererState;
    signalingState: RTCSignalingState;
    negotiationneeded: boolean;
    private readonly transceivers;
    private pushTransceiver;
    private replaceTransceiver;
    needRestart: boolean;
    readonly iceGatheringStateChange: Event<["complete" | "new" | "gathering"]>;
    readonly iceConnectionStateChange: Event<["disconnected" | "closed" | "completed" | "new" | "connected" | "failed" | "checking"]>;
    readonly signalingStateChange: Event<["closed" | "stable" | "have-local-offer" | "have-remote-offer" | "have-local-pranswer" | "have-remote-pranswer"]>;
    readonly connectionStateChange: Event<["disconnected" | "closed" | "new" | "connected" | "connecting" | "failed"]>;
    readonly onDataChannel: Event<[RTCDataChannel]>;
    readonly onRemoteTransceiverAdded: Event<[RTCRtpTransceiver]>;
    readonly onTransceiverAdded: Event<[RTCRtpTransceiver]>;
    readonly onIceCandidate: Event<[RTCIceCandidate | undefined]>;
    readonly onNegotiationneeded: Event<[]>;
    readonly onTrack: Event<[MediaStreamTrack]>;
    ondatachannel?: CallbackWithValue<RTCDataChannelEvent>;
    onicecandidate?: CallbackWithValue<RTCPeerConnectionIceEvent>;
    onnegotiationneeded?: CallbackWithValue<any>;
    onsignalingstatechange?: CallbackWithValue<any>;
    ontrack?: CallbackWithValue<RTCTrackEvent>;
    onconnectionstatechange?: Callback;
    oniceconnectionstatechange?: Callback;
    private readonly router;
    private certificate?;
    sctpRemotePort?: number;
    private seenMid;
    private currentLocalDescription?;
    private currentRemoteDescription?;
    private pendingLocalDescription?;
    private pendingRemoteDescription?;
    private isClosed;
    private shouldNegotiationneeded;
    get dtlsTransports(): RTCDtlsTransport[];
    get iceTransports(): RTCIceTransport[];
    get extIdUriMap(): {
        [id: number]: string;
    };
    get iceGeneration(): number;
    constructor(config?: Partial<PeerConfig>);
    setConfiguration(config: Partial<PeerConfig>): void;
    get localDescription(): import("./sdp").RTCSessionDescription | undefined;
    get remoteDescription(): import("./sdp").RTCSessionDescription | undefined;
    /**@private */
    get _localDescription(): SessionDescription | undefined;
    /**@private */
    get _remoteDescription(): SessionDescription | undefined;
    private getTransceiverByMid;
    private getTransceiverByMLineIndex;
    getConfiguration(): Required<PeerConfig>;
    createOffer({ iceRestart }?: {
        iceRestart?: boolean;
    }): Promise<import("./sdp").RTCSessionDescription>;
    private assignTransceiverCodecs;
    buildOfferSdp(): SessionDescription;
    createDataChannel(label: string, options?: Partial<{
        maxPacketLifeTime?: number;
        protocol: string;
        maxRetransmits?: number;
        ordered: boolean;
        negotiated: boolean;
        id?: number;
    }>): RTCDataChannel;
    removeTrack(sender: RTCRtpSender): void;
    private needNegotiation;
    private createTransport;
    private createSctpTransport;
    setLocalDescription(sessionDescription: {
        type: "offer" | "answer";
        sdp: string;
    }): Promise<SessionDescription>;
    private gatherCandidates;
    private setLocal;
    private getTransportByMid;
    private getTransportByMLineIndex;
    addIceCandidate(candidateMessage: RTCIceCandidate | RTCIceCandidateInit): Promise<void>;
    private connect;
    private getLocalRtpParams;
    private getRemoteRtpParams;
    get remoteIsBundled(): GroupDescription | undefined;
    restartIce(): void;
    setRemoteDescription(sessionDescription: RTCSessionDescriptionInit): Promise<void>;
    private setRemoteRTP;
    private setRemoteSCTP;
    private validateDescription;
    private fireOnTrack;
    addTransceiver(trackOrKind: Kind | MediaStreamTrack, options?: Partial<TransceiverOptions>): RTCRtpTransceiver;
    private _addTransceiver;
    getTransceivers(): RTCRtpTransceiver[];
    getSenders(): RTCRtpSender[];
    getReceivers(): RTCRtpReceiver[];
    addTrack(track: MediaStreamTrack, 
    /**todo impl */
    ms?: MediaStream): RTCRtpSender;
    private ensureCerts;
    createAnswer(): Promise<import("./sdp").RTCSessionDescription>;
    private buildAnswer;
    close(): Promise<void>;
    private assertNotClosed;
    private updateIceGatheringState;
    private updateIceConnectionState;
    private setSignalingState;
    private setConnectionState;
    private dispose;
}
export declare function createMediaDescriptionForTransceiver(transceiver: RTCRtpTransceiver, cname: string, direction: Direction): MediaDescription;
export declare function createMediaDescriptionForSctp(sctp: RTCSctpTransport): MediaDescription;
export declare function addTransportDescription(media: MediaDescription, dtlsTransport: RTCDtlsTransport): void;
export declare function allocateMid(mids: Set<string>, type: "dc" | "av" | ""): string;
export type BundlePolicy = "max-compat" | "max-bundle" | "disable";
export interface PeerConfig {
    codecs: Partial<{
        /**
         * When specifying a codec with a fixed payloadType such as PCMU,
         * it is necessary to set the correct PayloadType in RTCRtpCodecParameters in advance.
         */
        audio: RTCRtpCodecParameters[];
        video: RTCRtpCodecParameters[];
    }>;
    headerExtensions: Partial<{
        audio: RTCRtpHeaderExtensionParameters[];
        video: RTCRtpHeaderExtensionParameters[];
    }>;
    iceTransportPolicy: "all" | "relay";
    iceServers: RTCIceServer[];
    /**Minimum port and Maximum port must not be the same value */
    icePortRange: [number, number] | undefined;
    iceInterfaceAddresses: InterfaceAddresses | undefined;
    /** Add additional host (local) addresses to use for candidate gathering.
     * Notably, you can include hosts that are normally excluded, such as loopback, tun interfaces, etc.
     */
    iceAdditionalHostAddresses: string[] | undefined;
    iceUseIpv4: boolean;
    iceUseIpv6: boolean;
    forceTurnTCP: boolean;
    /** such as google cloud run */
    iceUseLinkLocalAddress: boolean | undefined;
    /** If provided, is called on each STUN request.
     * Return `true` if a STUN response should be sent, false if it should be skipped. */
    iceFilterStunResponse: ((message: Message, addr: Address, protocol: Protocol) => boolean) | undefined;
    iceFilterCandidatePair: ((pair: CandidatePair) => boolean) | undefined;
    dtls: Partial<{
        keys: DtlsKeys;
    }>;
    icePasswordPrefix: string | undefined;
    bundlePolicy: BundlePolicy;
    debug: Partial<{
        /**% */
        inboundPacketLoss: number;
        /**% */
        outboundPacketLoss: number;
        /**ms */
        receiverReportDelay: number;
        disableSendNack: boolean;
        disableRecvRetransmit: boolean;
    }>;
    midSuffix: boolean;
}
export declare const findCodecByMimeType: (codecs: RTCRtpCodecParameters[], target: RTCRtpCodecParameters) => RTCRtpCodecParameters | undefined;
export type RTCIceServer = {
    urls: string;
    username?: string;
    credential?: string;
};
export declare const defaultPeerConfig: PeerConfig;
export interface RTCTrackEvent {
    track: MediaStreamTrack;
    streams: MediaStream[];
    transceiver: RTCRtpTransceiver;
    receiver: RTCRtpReceiver;
}
export interface RTCDataChannelEvent {
    channel: RTCDataChannel;
}
export interface RTCPeerConnectionIceEvent {
    candidate?: RTCIceCandidate;
}
export interface RTCSessionDescriptionInit {
    sdp?: string;
    type: RTCSdpType;
}
export type RTCSdpType = "answer" | "offer" | "pranswer" | "rollback";
